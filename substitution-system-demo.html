<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Substitution Systems Demo - NKS Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .header h1 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .header p {
            color: #b8b8b8;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .control-panel h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            color: #d0d0d0;
            margin-bottom: 5px;
            font-weight: 500;
        }

        select, input[type="range"], input[type="text"], button, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            font-size: 14px;
        }

        textarea {
            resize: vertical;
            height: 60px;
            font-family: 'Courier New', monospace;
        }

        button {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.3));
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px 0;
        }

        button:hover {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.4));
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.2);
        }

        .visualization-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            text-align: center;
            margin-bottom: 20px;
        }

        .string-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .generation {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.02);
        }

        .generation-number {
            color: #ffd700;
            font-weight: bold;
            min-width: 40px;
            margin-right: 10px;
        }

        .string-content {
            flex: 1;
            word-break: break-all;
            color: #e0e0e0;
        }

        .symbol {
            display: inline-block;
            margin: 0 1px;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .symbol-A { background: #ff6b6b; color: white; }
        .symbol-B { background: #4ecdc4; color: white; }
        .symbol-0 { background: #ffffff; color: black; }
        .symbol-1 { background: #45b7d1; color: white; }
        .symbol-X { background: #96ceb4; color: white; }
        .symbol-Y { background: #ffd93d; color: black; }
        .symbol-L { background: #ff8c94; color: white; }
        .symbol-R { background: #a8e6cf; color: black; }

        .rules-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .rules-display h4 {
            color: #ffd700;
            margin-bottom: 10px;
            text-align: center;
        }

        .rule-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .rule-item {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
        }

        .rule-arrow {
            color: #ffd700;
            margin: 0 10px;
        }

        .tree-visualization {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow: auto;
        }

        .tree-node {
            margin: 2px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .custom-rules-editor {
            display: none;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .info-panel h3 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .info-panel p {
            color: #d0d0d0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            color: #b8b8b8;
        }

        .growth-chart {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            height: 200px;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .rule-list {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Substitution Systems Demo</h1>
            <p>Explore Wolfram's substitution systems from "A New Kind of Science"<br>
               String rewriting systems that generate complex patterns through simple rules</p>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h3>System Selection</h3>
                <div class="control-group">
                    <label for="systemPreset">Predefined Systems:</label>
                    <select id="systemPreset">
                        <option value="fibonacci">Fibonacci System (A→AB, B→A)</option>
                        <option value="binary">Binary Growth (0→01, 1→10)</option>
                        <option value="thue">Thue-Morse (0→01, 1→10)</option>
                        <option value="cantor">Cantor Set (A→ABA, B→BBB)</option>
                        <option value="dragon">Dragon Curve (X→X+YF+, Y→-FX-Y)</option>
                        <option value="koch">Koch Snowflake (F→F-F++F-F)</option>
                        <option value="sierpinski">Sierpinski (A→B-A-B, B→A+B+A)</option>
                        <option value="lsystem">L-System Plant (X→F-[[X]+X]+F[+FX]-X)</option>
                        <option value="custom">Custom System</option>
                    </select>
                </div>
                
                <div class="custom-rules-editor" id="customRulesEditor">
                    <label for="customRules">Custom Rules (one per line, format: A→BC):</label>
                    <textarea id="customRules" placeholder="A→AB&#10;B→A"></textarea>
                    <button id="applyCustom">Apply Custom Rules</button>
                </div>
            </div>

            <div class="control-panel">
                <h3>Evolution Control</h3>
                <div class="control-group">
                    <label for="speed">Animation Speed:</label>
                    <input type="range" id="speed" min="100" max="2000" value="800">
                    <span id="speedValue">800ms</span>
                </div>
                <div class="control-group">
                    <label for="maxGenerations">Max Generations:</label>
                    <input type="range" id="maxGenerations" min="5" max="20" value="12">
                    <span id="maxGenValue">12</span>
                </div>
                <button id="startBtn">Start Evolution</button>
                <button id="stopBtn">Stop Evolution</button>
                <button id="stepBtn">Single Step</button>
                <button id="resetBtn">Reset System</button>
            </div>

            <div class="control-panel">
                <h3>Initial Configuration</h3>
                <div class="control-group">
                    <label for="initialString">Starting String:</label>
                    <input type="text" id="initialString" value="A" placeholder="e.g., A, 0, AB">
                </div>
                <div class="control-group">
                    <label for="viewMode">Visualization Mode:</label>
                    <select id="viewMode">
                        <option value="string">String Sequence</option>
                        <option value="tree">Tree Structure</option>
                        <option value="growth">Growth Chart</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="visualization-container">
            <h3 style="color: #ffd700; margin-bottom: 15px;">Substitution System Evolution</h3>
            
            <div class="rules-display" id="rulesDisplay">
                <h4>Current Rules</h4>
                <div class="rule-list" id="ruleList"></div>
            </div>

            <div class="string-display" id="stringDisplay"></div>
            
            <div class="tree-visualization" id="treeVisualization" style="display: none;"></div>
            
            <canvas id="growthChart" width="800" height="200" style="display: none; max-width: 100%;"></canvas>
        </div>

        <div class="info-panel">
            <h3>About Substitution Systems</h3>
            <p>
                Substitution systems, extensively studied by Stephen Wolfram in "A New Kind of Science," are 
                computational systems that operate by repeatedly applying <strong>string rewriting rules</strong>. 
                Starting from an initial string (axiom), each symbol is simultaneously replaced according to 
                predefined rules, generating increasingly complex patterns.
            </p>
            <p>
                These systems are closely related to <strong>L-systems</strong> (Lindenmayer systems) and demonstrate 
                how simple rules can generate <strong>fractal patterns</strong>, biological growth models, and 
                complex mathematical sequences like the Fibonacci sequence. Wolfram showed that even 
                <strong>neighbor-independent</strong> substitution rules can produce sophisticated emergent behaviors.
            </p>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="currentGeneration">0</div>
                    <div class="stat-label">Generation</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stringLength">1</div>
                    <div class="stat-label">String Length</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="growthRate">1.0</div>
                    <div class="stat-label">Growth Rate</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="uniqueSymbols">1</div>
                    <div class="stat-label">Unique Symbols</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalSymbols">1</div>
                    <div class="stat-label">Total Symbols</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SubstitutionSystem {
            constructor() {
                this.rules = {};
                this.initialString = "A";
                this.generations = [];
                this.currentGeneration = 0;
                this.isRunning = false;
                this.animationId = null;
                this.maxGenerations = 12;
                this.viewMode = "string";
                
                this.initializeSystem();
            }

            initializeSystem() {
                // Default Fibonacci system (NKS page 82)
                this.rules = {
                    "A": "AB",
                    "B": "A"
                };
                
                this.reset();
                this.updateRulesDisplay();
            }

            setSystem(preset) {
                switch (preset) {
                    case 'fibonacci':
                        this.rules = { "A": "AB", "B": "A" };
                        this.initialString = "A";
                        break;
                    case 'binary':
                        this.rules = { "0": "01", "1": "10" };
                        this.initialString = "0";
                        break;
                    case 'thue':
                        this.rules = { "0": "01", "1": "10" };
                        this.initialString = "0";
                        break;
                    case 'cantor':
                        this.rules = { "A": "ABA", "B": "BBB" };
                        this.initialString = "A";
                        break;
                    case 'dragon':
                        this.rules = { "X": "X+YF+", "Y": "-FX-Y", "F": "F", "+": "+", "-": "-" };
                        this.initialString = "FX";
                        break;
                    case 'koch':
                        this.rules = { "F": "F-F++F-F", "-": "-", "+": "+" };
                        this.initialString = "F";
                        break;
                    case 'sierpinski':
                        this.rules = { "A": "B-A-B", "B": "A+B+A", "-": "-", "+": "+" };
                        this.initialString = "A";
                        break;
                    case 'lsystem':
                        this.rules = { 
                            "X": "F-[[X]+X]+F[+FX]-X",
                            "F": "FF",
                            "+": "+", "-": "-", "[": "[", "]": "]"
                        };
                        this.initialString = "X";
                        break;
                }
                
                this.updateRulesDisplay();
                this.reset();
            }

            setCustomRules(rulesText) {
                const rules = {};
                const lines = rulesText.split('\n');
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed && trimmed.includes('→')) {
                        const [left, right] = trimmed.split('→');
                        if (left && right) {
                            rules[left.trim()] = right.trim();
                        }
                    }
                }
                
                if (Object.keys(rules).length > 0) {
                    this.rules = rules;
                    this.updateRulesDisplay();
                    this.reset();
                    return true;
                }
                return false;
            }

            reset() {
                this.stop();
                this.generations = [this.initialString];
                this.currentGeneration = 0;
                this.updateDisplay();
                this.updateStats();
            }

            step() {
                if (this.currentGeneration >= this.maxGenerations - 1) {
                    this.stop();
                    return false;
                }

                const currentString = this.generations[this.currentGeneration];
                let newString = "";
                
                // Apply substitution rules
                for (const char of currentString) {
                    if (this.rules[char]) {
                        newString += this.rules[char];
                    } else {
                        newString += char; // No rule, keep original
                    }
                }
                
                this.currentGeneration++;
                this.generations[this.currentGeneration] = newString;
                
                this.updateDisplay();
                this.updateStats();
                
                return true;
            }

            updateRulesDisplay() {
                const ruleList = document.getElementById('ruleList');
                ruleList.innerHTML = '';
                
                Object.entries(this.rules).forEach(([key, value]) => {
                    const ruleItem = document.createElement('div');
                    ruleItem.className = 'rule-item';
                    ruleItem.innerHTML = `
                        <span class="symbol symbol-${key}">${key}</span>
                        <span class="rule-arrow">→</span>
                        ${this.formatString(value, true)}
                    `;
                    ruleList.appendChild(ruleItem);
                });
            }

            formatString(str, isRule = false) {
                return str.split('').map(char => 
                    `<span class="symbol symbol-${char}">${char}</span>`
                ).join('');
            }

            updateDisplay() {
                switch (this.viewMode) {
                    case 'string':
                        this.updateStringDisplay();
                        break;
                    case 'tree':
                        this.updateTreeDisplay();
                        break;
                    case 'growth':
                        this.updateGrowthChart();
                        break;
                }
            }

            updateStringDisplay() {
                const stringDisplay = document.getElementById('stringDisplay');
                const treeVisualization = document.getElementById('treeVisualization');
                const growthChart = document.getElementById('growthChart');
                
                stringDisplay.style.display = 'block';
                treeVisualization.style.display = 'none';
                growthChart.style.display = 'none';
                
                stringDisplay.innerHTML = '';
                
                for (let i = 0; i <= this.currentGeneration; i++) {
                    const generation = document.createElement('div');
                    generation.className = 'generation';
                    
                    const genNumber = document.createElement('div');
                    genNumber.className = 'generation-number';
                    genNumber.textContent = i + ':';
                    
                    const stringContent = document.createElement('div');
                    stringContent.className = 'string-content';
                    
                    const str = this.generations[i];
                    if (str.length > 200) {
                        stringContent.innerHTML = this.formatString(str.substring(0, 200)) + 
                            `<span style="color: #888;"> ... (${str.length - 200} more characters)</span>`;
                    } else {
                        stringContent.innerHTML = this.formatString(str);
                    }
                    
                    generation.appendChild(genNumber);
                    generation.appendChild(stringContent);
                    stringDisplay.appendChild(generation);
                }
                
                stringDisplay.scrollTop = stringDisplay.scrollHeight;
            }

            updateTreeDisplay() {
                const stringDisplay = document.getElementById('stringDisplay');
                const treeVisualization = document.getElementById('treeVisualization');
                const growthChart = document.getElementById('growthChart');
                
                stringDisplay.style.display = 'none';
                treeVisualization.style.display = 'block';
                growthChart.style.display = 'none';
                
                treeVisualization.innerHTML = '';
                
                for (let i = 0; i <= this.currentGeneration; i++) {
                    const treeNode = document.createElement('div');
                    treeNode.className = 'tree-node';
                    treeNode.style.paddingLeft = (i * 20) + 'px';
                    treeNode.style.color = `hsl(${(i * 30) % 360}, 70%, 70%)`;
                    
                    const str = this.generations[i];
                    const prefix = '│ '.repeat(i) + '├─ ';
                    
                    if (str.length > 100) {
                        treeNode.textContent = prefix + str.substring(0, 100) + `... (${str.length} total)`;
                    } else {
                        treeNode.textContent = prefix + str;
                    }
                    
                    treeVisualization.appendChild(treeNode);
                }
                
                treeVisualization.scrollTop = treeVisualization.scrollHeight;
            }

            updateGrowthChart() {
                const stringDisplay = document.getElementById('stringDisplay');
                const treeVisualization = document.getElementById('treeVisualization');
                const growthChart = document.getElementById('growthChart');
                
                stringDisplay.style.display = 'none';
                treeVisualization.style.display = 'none';
                growthChart.style.display = 'block';
                
                const canvas = growthChart;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (this.generations.length < 2) return;
                
                const lengths = this.generations.slice(0, this.currentGeneration + 1).map(str => str.length);
                const maxLength = Math.max(...lengths);
                const maxGen = lengths.length - 1;
                
                // Draw grid
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = (canvas.height * i) / 10;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                for (let i = 0; i <= maxGen; i++) {
                    const x = (canvas.width * i) / maxGen;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Draw growth curve
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < lengths.length; i++) {
                    const x = (canvas.width * i) / maxGen;
                    const y = canvas.height - (canvas.height * lengths[i]) / maxLength;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Draw points
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
                
                ctx.stroke();
                
                // Draw labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px monospace';
                ctx.fillText(`Max Length: ${maxLength}`, 10, 20);
                ctx.fillText(`Generation: ${this.currentGeneration}`, 10, 35);
            }

            updateStats() {
                const currentString = this.generations[this.currentGeneration] || "";
                const uniqueSymbols = new Set(currentString).size;
                
                let growthRate = 1.0;
                if (this.currentGeneration > 0) {
                    const prevLength = this.generations[this.currentGeneration - 1].length;
                    const currLength = currentString.length;
                    growthRate = prevLength > 0 ? (currLength / prevLength) : 1.0;
                }
                
                document.getElementById('currentGeneration').textContent = this.currentGeneration;
                document.getElementById('stringLength').textContent = currentString.length;
                document.getElementById('growthRate').textContent = growthRate.toFixed(2);
                document.getElementById('uniqueSymbols').textContent = uniqueSymbols;
                document.getElementById('totalSymbols').textContent = currentString.length;
            }

            start(speed = 800) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                const animate = () => {
                    if (!this.isRunning) return;
                    
                    const canContinue = this.step();
                    if (!canContinue) {
                        this.isRunning = false;
                        return;
                    }
                    
                    this.animationId = setTimeout(animate, speed);
                };
                animate();
            }

            stop() {
                this.isRunning = false;
                if (this.animationId) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
            }

            setViewMode(mode) {
                this.viewMode = mode;
                this.updateDisplay();
            }

            setMaxGenerations(max) {
                this.maxGenerations = max;
            }

            setInitialString(str) {
                this.initialString = str || "A";
                this.reset();
            }
        }

        // Initialize the substitution system
        const ss = new SubstitutionSystem();

        // Event listeners
        document.getElementById('systemPreset').addEventListener('change', (e) => {
            const preset = e.target.value;
            const customEditor = document.getElementById('customRulesEditor');
            
            if (preset === 'custom') {
                customEditor.style.display = 'block';
            } else {
                customEditor.style.display = 'none';
                ss.setSystem(preset);
            }
        });

        document.getElementById('applyCustom').addEventListener('click', () => {
            const rulesText = document.getElementById('customRules').value;
            if (!ss.setCustomRules(rulesText)) {
                alert('Invalid rule format. Use format: A→BC (one rule per line)');
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('maxGenerations').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('maxGenValue').textContent = value;
            ss.setMaxGenerations(value);
        });

        document.getElementById('viewMode').addEventListener('change', (e) => {
            ss.setViewMode(e.target.value);
        });

        document.getElementById('initialString').addEventListener('change', (e) => {
            ss.setInitialString(e.target.value);
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            const speed = parseInt(document.getElementById('speed').value);
            ss.start(speed);
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            ss.stop();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            ss.step();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            const initialStr = document.getElementById('initialString').value;
            ss.setInitialString(initialStr);
        });
    </script>
</body>
</html>