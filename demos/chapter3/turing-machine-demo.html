<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Turing Machines – NKS Chapter 3</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #f4f4f4;
      color: #1f1f1f;
    }
    main { max-width: 900px; margin: 0 auto; padding: 30px 20px 40px; }
    header { margin-bottom: 22px; }
    h1 { margin: 0 0 0.4rem; font-size: 1.9rem; }
    p { margin: 0; line-height: 1.55; }
    section {
      background: #fff;
      border: 1px solid #d8d8d8;
      border-radius: 10px;
      padding: 18px 20px;
      margin-bottom: 18px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    .controls { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    label { display: block; font-weight: 600; margin-bottom: 6px; }
    select, button {
      font: inherit;
      padding: 7px 9px;
      border-radius: 6px;
      border: 1px solid #b6b6b6;
      background: #fff;
      width: 100%;
    }
    button {
      background: #1f63c7;
      border-color: #1f63c7;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    button.secondary {
      background: #f2f2f2;
      border-color: #c2c2c2;
      color: #222;
    }
    button + button { margin-top: 8px; }
    canvas {
      width: 100%;
      border: 1px solid #9c9c9c;
      background: #fff;
      display: block;
      image-rendering: pixelated;
    }
    table {
      border-collapse: collapse;
      margin-top: 14px;
      width: 100%;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #c8c8c8;
      padding: 6px 8px;
      text-align: center;
    }
    th { background: #f1f1f1; }
    .stats { display: flex; flex-wrap: wrap; gap: 16px; font-size: 0.95rem; margin-top: 12px; }
    .stat { min-width: 120px; }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Small Turing Machines</h1>
      <p>
        These machines are the exact ones illustrated on pages 78–81 of <em>A New Kind of Science</em>. Each rule is presented
        in Wolfram’s numbering scheme: states are numbered 1…N, tape symbols are 0 or 1, and every entry specifies the next
        state, the symbol to write, and whether the head moves left or right. The timeline view matches the original demo by
        showing a head-centred window of 81 cells for each step.
      </p>
    </header>

    <section class="controls">
      <div>
        <label for="machine-select">Select machine</label>
        <select id="machine-select">
          <option value="simple2">Page 78 · 2-state example</option>
          <option value="3024">Wolfram machine 3024</option>
          <option value="982">Wolfram machine 982</option>
          <option value="925">Wolfram machine 925</option>
        </select>
      </div>
      <div>
        <label>Simulation control</label>
        <button id="run-btn">Run</button>
        <button id="step-btn" class="secondary">Step once</button>
        <button id="reset-btn" class="secondary">Reset</button>
      </div>
      <div>
        <label for="window-size">Visible window</label>
        <select id="window-size">
          <option value="41">41 cells</option>
          <option value="61">61 cells</option>
          <option value="81" selected>81 cells</option>
        </select>
      </div>
    </section>

    <section>
      <canvas id="tm-canvas" width="860" height="460"></canvas>
      <div class="stats">
        <div class="stat"><strong>Steps:</strong> <span id="step-count">0</span></div>
        <div class="stat"><strong>State:</strong> <span id="state">1</span></div>
        <div class="stat"><strong>Head position:</strong> <span id="head">0</span></div>
      </div>
      <table id="rule-table"></table>
    </section>
  </main>

  <script>
    const PRESETS = {
      simple2: {
        initialState: 1,
        rules: {
          '1,0': [2, 1, 'R'],
          '1,1': [2, 0, 'L'],
          '2,0': [1, 1, 'L'],
          '2,1': [1, 1, 'R']
        }
      },
      3024: {
        initialState: 1,
        rules: {
          '1,0': [3, 1, 'L'],
          '1,1': [2, 0, 'R'],
          '2,0': [1, 1, 'R'],
          '2,1': [3, 1, 'R'],
          '3,0': [2, 1, 'R'],
          '3,1': [1, 0, 'L']
        }
      },
      982: {
        initialState: 1,
        rules: {
          '1,0': [2, 1, 'R'],
          '1,1': [3, 0, 'R'],
          '2,0': [3, 1, 'L'],
          '2,1': [2, 0, 'R'],
          '3,0': [1, 1, 'L'],
          '3,1': [1, 0, 'L']
        }
      },
      925: {
        initialState: 1,
        rules: {
          '1,0': [2, 1, 'R'],
          '1,1': [3, 0, 'L'],
          '2,0': [3, 1, 'L'],
          '2,1': [2, 0, 'R'],
          '3,0': [1, 1, 'L'],
          '3,1': [1, 0, 'R']
        }
      }
    };

    class TuringMachineDemo {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.window = 81;
        this.setMachine('simple2');
        this.running = false;
        this.timer = null;
      }

      setMachine(name) {
        const preset = PRESETS[name];
        this.rules = preset.rules;
        this.initialState = preset.initialState;
        this.reset();
        this.updateRuleTable();
      }

      reset() {
        this.stop();
        this.tape = new Map();
        this.head = 0;
        this.state = this.initialState;
        this.steps = 0;
        this.history = [];
        this.recordHistory();
        this.draw();
        this.updateStats();
      }

      read(position) {
        return this.tape.has(position) ? this.tape.get(position) : 0;
      }

      write(position, value) {
        if (value === 0) {
          this.tape.delete(position);
        } else {
          this.tape.set(position, value);
        }
      }

      recordHistory() {
        const half = Math.floor(this.window / 2);
        const row = [];
        for (let offset = -half; offset <= half; offset++) {
          row.push(this.read(this.head + offset));
        }
        this.history.push({ row, headIndex: half });
        if (this.history.length > 220) {
          this.history.shift();
        }
      }

      step() {
        const symbol = this.read(this.head);
        const rule = this.rules[`${this.state},${symbol}`];
        if (!rule) {
          this.stop();
          return;
        }
        const [nextState, writeSymbol, move] = rule;
        this.write(this.head, writeSymbol);
        this.head += (move === 'L' ? -1 : 1);
        this.state = nextState;
        this.steps += 1;
        this.recordHistory();
        this.draw();
        this.updateStats();
      }

      run() {
        if (this.running) return;
        this.running = true;
        const loop = () => {
          if (!this.running) return;
          this.step();
          this.timer = setTimeout(() => requestAnimationFrame(loop), 90);
        };
        loop();
      }

      stop() {
        this.running = false;
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
      }

      draw() {
        const { width, height } = this.canvas;
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, width, height);
        const cellWidth = width / this.window;
        const rowHeight = height / this.history.length;
        this.history.forEach((entry, idx) => {
          const y = idx * rowHeight;
          entry.row.forEach((value, cellIdx) => {
            if (value === 1) {
              this.ctx.fillStyle = '#000';
              this.ctx.fillRect(cellIdx * cellWidth, y, cellWidth, rowHeight);
            }
          });
          this.ctx.strokeStyle = '#d62828';
          this.ctx.lineWidth = 1.5;
          this.ctx.strokeRect(entry.headIndex * cellWidth, y, cellWidth, rowHeight);
        });
      }

      updateStats() {
        document.getElementById('step-count').textContent = this.steps.toString();
        document.getElementById('state').textContent = this.state.toString();
        document.getElementById('head').textContent = this.head.toString();
      }

      updateRuleTable() {
        const table = document.getElementById('rule-table');
        table.innerHTML = '';
        const header = document.createElement('tr');
        header.innerHTML = '<th>State</th><th>Read</th><th>Write</th><th>Move</th><th>Next state</th>';
        table.appendChild(header);
        Object.entries(this.rules).forEach(([key, value]) => {
          const [state, read] = key.split(',');
          const [nextState, writeSymbol, move] = value;
          const row = document.createElement('tr');
          row.innerHTML = `<td>${state}</td><td>${read}</td><td>${writeSymbol}</td><td>${move}</td><td>${nextState}</td>`;
          table.appendChild(row);
        });
      }

      setWindow(size) {
        this.window = size;
        this.history = [];
        this.recordHistory();
        this.draw();
      }
    }

    const canvas = document.getElementById('tm-canvas');
    const demo = new TuringMachineDemo(canvas);

    document.getElementById('machine-select').addEventListener('change', (event) => {
      demo.setMachine(event.target.value);
      document.getElementById('run-btn').textContent = 'Run';
    });

    document.getElementById('window-size').addEventListener('change', (event) => {
      demo.setWindow(parseInt(event.target.value, 10));
    });

    document.getElementById('run-btn').addEventListener('click', () => {
      if (demo.running) {
        demo.stop();
        document.getElementById('run-btn').textContent = 'Run';
      } else {
        demo.run();
        document.getElementById('run-btn').textContent = 'Pause';
      }
    });

    document.getElementById('step-btn').addEventListener('click', () => {
      demo.stop();
      document.getElementById('run-btn').textContent = 'Run';
      demo.step();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      demo.reset();
      document.getElementById('run-btn').textContent = 'Run';
    });
  </script>
</body>
</html>
