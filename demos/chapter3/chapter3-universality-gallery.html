<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Behavior Atlas · Chapter 3 | A New Kind of Science</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: radial-gradient(circle at top, rgba(17, 24, 39, 0.9), #020617 55%);
            color: #f8fafc;
        }

        .behavior-button {
            transition: all 0.25s ease;
        }

        .behavior-button.active {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.35));
            border-color: rgba(245, 158, 11, 0.7);
            color: #fde68a;
        }

        canvas {
            background-color: rgba(15, 23, 42, 0.85);
        }

        .system-card {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 1.25rem;
            padding: 1.75rem;
            box-shadow: 0 25px 60px rgba(2, 6, 23, 0.45);
            backdrop-filter: blur(14px);
        }

        .system-card h2 {
            letter-spacing: 0.04em;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 9999px;
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <a href="index.html" class="inline-flex items-center text-sm text-slate-300 hover:text-amber-300 transition">
            ← Back to Chapter 3 demos
        </a>

        <header class="mt-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-amber-300 tracking-tight">
                Behavior Atlas · Universal Patterns in Simple Programs
            </h1>
            <p class="mt-4 text-lg text-slate-300 leading-relaxed max-w-3xl">
                Chapter 3 of <em>A New Kind of Science</em> reveals that simple rules across many models of computation fall into
                the same four behavioral classes. This gallery lets you switch among those classes and immediately compare how
                a cellular automaton, a head-based system, and a tag system express the very same theme.
            </p>
        </header>

        <div class="mt-8 flex flex-wrap gap-3" id="behavior-buttons">
            <button class="behavior-button px-4 py-2 rounded-full border border-slate-700 text-sm font-medium text-slate-200"
                data-behavior="repetition">Class 1 · Repetition</button>
            <button class="behavior-button px-4 py-2 rounded-full border border-slate-700 text-sm font-medium text-slate-200"
                data-behavior="nesting">Class 2 · Nesting</button>
            <button class="behavior-button px-4 py-2 rounded-full border border-slate-700 text-sm font-medium text-slate-200"
                data-behavior="randomness">Class 3 · Randomness</button>
            <button class="behavior-button px-4 py-2 rounded-full border border-slate-700 text-sm font-medium text-slate-200"
                data-behavior="complexity">Class 4 · Complexity</button>
        </div>

        <p id="behavior-summary" class="mt-6 text-base sm:text-lg text-slate-200 max-w-4xl leading-relaxed"></p>

        <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6" id="systems-grid">
            <div class="system-card">
                <div class="flex items-baseline justify-between mb-4">
                    <h2 class="text-xl font-semibold text-amber-200">Cellular Automaton</h2>
                    <span class="text-xs uppercase tracking-widest text-slate-400">parallel update</span>
                </div>
                <canvas id="caCanvas" width="600" height="360" class="w-full rounded-xl border border-slate-800"></canvas>
                <p id="caCaption" class="mt-4 text-sm text-slate-300 leading-relaxed"></p>
            </div>

            <div class="system-card">
                <div class="flex items-baseline justify-between mb-4">
                    <h2 class="text-xl font-semibold text-amber-200">Turing Machine</h2>
                    <span class="text-xs uppercase tracking-widest text-slate-400">single head</span>
                </div>
                <canvas id="tmCanvas" width="600" height="360" class="w-full rounded-xl border border-slate-800"></canvas>
                <p id="tmCaption" class="mt-4 text-sm text-slate-300 leading-relaxed"></p>
            </div>

            <div class="system-card">
                <div class="flex items-baseline justify-between mb-4">
                    <h2 class="text-xl font-semibold text-amber-200">Tag System</h2>
                    <span class="text-xs uppercase tracking-widest text-slate-400">growth dynamics</span>
                </div>
                <canvas id="tagCanvas" width="600" height="360" class="w-full rounded-xl border border-slate-800"></canvas>
                <div id="tagLegend" class="mt-4 text-xs text-slate-400 space-y-1"></div>
                <p id="tagCaption" class="mt-4 text-sm text-slate-300 leading-relaxed"></p>
            </div>
        </div>

        <section class="mt-12 bg-slate-900/50 border border-slate-800 rounded-2xl p-6">
            <h2 class="text-lg font-semibold text-amber-200">How to read this gallery</h2>
            <p class="mt-3 text-slate-300 leading-relaxed">
                Each canvas shows 120–200 steps of evolution. Rows correspond to successive steps, read from top to bottom. The
                cellular automaton colours mark active cells; the Turing machine visualisation tracks tape colours as the head
                sweeps; the tag system paints the evolving string after each deletion-and-append cycle. Switching classes makes it
                immediately obvious that—despite their very different mechanics—their long-term behaviour falls into the same
                categories Wolfram catalogues throughout Chapter 3.
            </p>
        </section>
    </div>

    <script>
        const behaviorData = {
            repetition: {
                summary: "Class 1 systems quickly settle into uniform or strictly periodic states. After a short transient, nothing surprising happens—yet the same stillness appears in parallel, sequential, and growth-based rules.",
                ca: {
                    rule: 250,
                    steps: 140,
                    width: 180,
                    caption: "Elementary Rule 250 rapidly becomes a uniform block. Starting from a single active cell, the pattern freezes into a repeating stripe, the hallmark of a Class 1 cellular automaton."
                },
                tm: {
                    startState: 1,
                    steps: 160,
                    transitions: {
                        "1,0": { next: 1, write: 1, move: 1 },
                        "1,1": { next: 1, write: 1, move: 1 }
                    },
                    palette: {
                        0: "#0f172a",
                        1: "#fbbf24"
                    },
                    caption: "A single-state Turing machine that always writes 1 and moves right. It fills the tape with one colour and never revisits earlier cells—an archetypal repetitive outcome."
                },
                tag: {
                    deletion: 1,
                    initial: "ABC",
                    rules: { A: "B", B: "C", C: "A" },
                    steps: 120,
                    palette: {
                        A: "#38bdf8",
                        B: "#f87171",
                        C: "#22c55e"
                    },
                    caption: "A cyclic 1-tag system that simply rotates symbols A→B→C. The sequence loops forever with period three, mirroring the frozen behaviour seen in the other models."
                }
            },
            nesting: {
                summary: "Class 2 behaviour builds regular, self-similar scaffolding. Even when the underlying rules differ dramatically, nested structures persist across models.",
                ca: {
                    rule: 90,
                    steps: 140,
                    width: 180,
                    caption: "Rule 90 produces the Sierpiński triangle from a single seed, displaying the crisp nested structure that defines Class 2 behaviour."
                },
                tm: {
                    startState: 1,
                    steps: 200,
                    transitions: {
                        "1,0": { next: 2, write: 1, move: 1 },
                        "1,1": { next: 2, write: 0, move: -1 },
                        "2,0": { next: 1, write: 1, move: -1 },
                        "2,1": { next: 1, write: 1, move: 1 }
                    },
                    palette: {
                        0: "#0f172a",
                        1: "#22d3ee"
                    },
                    caption: "A 2-state Turing machine from NKS that sweeps left and right in a perfectly regular rhythm, generating a nested chevron motif on its tape."
                },
                tag: {
                    deletion: 2,
                    initial: "AAB",
                    rules: { A: "AB", B: "AA" },
                    steps: 120,
                    palette: {
                        A: "#a855f7",
                        B: "#f97316"
                    },
                    caption: "This 2-tag system alternates between short repeated blocks. The deterministic cycle of AAB → BAB → BAA → AAA gives a visual stair-step reminiscent of nested substitution systems."
                }
            },
            randomness: {
                summary: "Class 3 systems generate apparent randomness. Deterministic rules still govern the evolution, yet the output looks statistically noisy and defies short descriptions.",
                ca: {
                    rule: 30,
                    steps: 140,
                    width: 180,
                    caption: "Rule 30 is Wolfram's canonical random-looking automaton. Even with a single black cell seed, the pattern becomes speckled noise."
                },
                tm: {
                    startState: 1,
                    steps: 220,
                    transitions: {
                        "1,0": { next: 2, write: 1, move: 1 },
                        "1,1": { next: 2, write: 1, move: -1 },
                        "2,0": { next: 3, write: 0, move: -1 },
                        "2,1": { next: 4, write: 1, move: 1 },
                        "3,0": { next: 4, write: 0, move: -1 },
                        "3,1": { next: 1, write: 0, move: -1 },
                        "4,0": { next: 1, write: 1, move: 1 },
                        "4,1": { next: 3, write: 0, move: 1 }
                    },
                    palette: {
                        0: "#0f172a",
                        1: "#f97316"
                    },
                    caption: "A 4-state, 2-colour Turing machine whose head thrashes unpredictably. The tape accumulates a turbulent band of orange cells—the sequential analogue of Rule 30's randomness."
                },
                tag: {
                    deletion: 2,
                    initial: "AB",
                    rules: { A: "BA", B: "ABB" },
                    steps: 120,
                    palette: {
                        A: "#0ea5e9",
                        B: "#ef4444"
                    },
                    caption: "A simple 2-tag system that repeatedly rearranges and appends symbols in a way that never repeats. Length and composition fluctuate erratically, giving a noisy horizontal texture."
                }
            },
            complexity: {
                summary: "Class 4 mixes pockets of order with bursts of randomness. Localised structures persist and interact, suggesting computational irreducibility. Chapter 3 highlights how this rich behaviour appears in many unrelated rules.",
                ca: {
                    rule: 110,
                    steps: 160,
                    width: 180,
                    caption: "Rule 110, later proven Turing complete, shows mobile structures colliding amid irregular background texture—classic Class 4 complexity."
                },
                tm: {
                    startState: 1,
                    steps: 220,
                    transitions: {
                        "1,0": { next: 3, write: 1, move: -1 },
                        "1,1": { next: 2, write: 0, move: 1 },
                        "2,0": { next: 1, write: 1, move: 1 },
                        "2,1": { next: 3, write: 1, move: 1 },
                        "3,0": { next: 2, write: 1, move: 1 },
                        "3,1": { next: 1, write: 0, move: -1 }
                    },
                    palette: {
                        0: "#0f172a",
                        1: "#facc15"
                    },
                    caption: "Wolfram's machine #3024 (3 states, 2 colours) develops moving fronts and recurring motifs without ever stabilising—mirroring the coexistence of order and surprise in Rule 110."
                },
                tag: {
                    deletion: 2,
                    initial: "AAA",
                    rules: { A: "BC", B: "A", C: "AAB" },
                    steps: 140,
                    palette: {
                        A: "#fbbf24",
                        B: "#38bdf8",
                        C: "#f472b6"
                    },
                    caption: "The classic Wolfram 2-tag system #925 spawns bursts of new symbols and recurrent motifs. Growth is irregular yet structured, echoing the intricate Class 4 behaviour seen in the other models."
                }
            }
        };

        const behaviorButtons = document.querySelectorAll('.behavior-button');
        const behaviorSummary = document.getElementById('behavior-summary');
        const caCanvas = document.getElementById('caCanvas');
        const tmCanvas = document.getElementById('tmCanvas');
        const tagCanvas = document.getElementById('tagCanvas');
        const caCaption = document.getElementById('caCaption');
        const tmCaption = document.getElementById('tmCaption');
        const tagCaption = document.getElementById('tagCaption');
        const tagLegend = document.getElementById('tagLegend');

        function renderCA(canvas, config) {
            const ctx = canvas.getContext('2d');
            const columns = config.width || 180;
            const rows = config.steps || 140;
            const cellSize = Math.max(1, Math.floor(canvas.width / columns));
            const rowSize = Math.max(1, Math.floor(canvas.height / rows));

            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const ruleBinary = config.rule.toString(2).padStart(8, '0').split('').reverse().map(Number);
            let current = new Array(columns).fill(0);
            current[Math.floor(columns / 2)] = 1;

            ctx.fillStyle = '#facc15';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    if (current[col] === 1) {
                        ctx.fillRect(col * cellSize, row * rowSize, cellSize, rowSize);
                    }
                }

                const next = new Array(columns).fill(0);
                for (let col = 0; col < columns; col++) {
                    const left = current[col - 1] || 0;
                    const centre = current[col];
                    const right = current[col + 1] || 0;
                    const index = (left << 2) | (centre << 1) | right;
                    next[col] = ruleBinary[index];
                }
                current = next;
            }
        }

        function renderTuring(canvas, config) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const steps = config.steps || 200;
            let state = config.startState || 1;
            let head = 0;
            const tape = new Map();
            const history = [];
            let minPos = 0;
            let maxPos = 0;

            for (let step = 0; step < steps; step++) {
                const currentVal = tape.get(head) || 0;
                const transition = config.transitions[`${state},${currentVal}`];
                if (!transition) break;

                tape.set(head, transition.write);
                history.push(new Map(tape));

                if (head < minPos) minPos = head;
                if (head > maxPos) maxPos = head;

                head += transition.move;
                state = transition.next;

                if (head < minPos) minPos = head;
                if (head > maxPos) maxPos = head;
            }

            const width = Math.max(1, maxPos - minPos + 1);
            if (history.length === 0) {
                return;
            }

            const cellSize = Math.max(1, Math.floor(canvas.width / width));
            const rowHeight = Math.max(1, Math.floor(canvas.height / history.length));

            for (let row = 0; row < history.length; row++) {
                const snapshot = history[row];
                const y = row * rowHeight;
                for (let x = 0; x < width; x++) {
                    const pos = x + minPos;
                    const value = snapshot.get(pos) || 0;
                    ctx.fillStyle = config.palette[value] || '#1e293b';
                    ctx.fillRect(x * cellSize, y, cellSize, rowHeight);
                }
            }
        }

        function renderTag(canvas, config) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let current = config.initial.split('');
            const history = [];
            let maxLen = current.length;
            const steps = config.steps || 120;

            for (let step = 0; step < steps; step++) {
                history.push(current.join(''));
                if (current.length === 0) break;
                maxLen = Math.max(maxLen, current.length);

                const symbol = current[0];
                const addition = (config.rules[symbol] || '').split('');
                current = current.slice(config.deletion).concat(addition);
            }

            const cellSize = Math.max(1, Math.floor(canvas.width / Math.max(1, maxLen)));
            const rowHeight = Math.max(1, Math.floor(canvas.height / Math.max(1, history.length)));

            for (let row = 0; row < history.length; row++) {
                const str = history[row];
                const y = row * rowHeight;
                for (let col = 0; col < str.length; col++) {
                    const symbol = str[col];
                    ctx.fillStyle = config.palette[symbol] || '#64748b';
                    ctx.fillRect(col * cellSize, y, cellSize, rowHeight);
                }
            }

            tagLegend.innerHTML = '';
            Object.entries(config.palette).forEach(([symbol, colour]) => {
                const item = document.createElement('div');
                item.innerHTML = `<span class="legend-dot" style="background:${colour}"></span><span class="ml-2">${symbol}</span>`;
                tagLegend.appendChild(item);
            });
        }

        function setBehavior(key) {
            const data = behaviorData[key];
            if (!data) return;

            behaviorButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.behavior === key));
            behaviorSummary.textContent = data.summary;

            renderCA(caCanvas, data.ca);
            caCaption.textContent = data.ca.caption;

            renderTuring(tmCanvas, data.tm);
            tmCaption.textContent = data.tm.caption;

            renderTag(tagCanvas, data.tag);
            tagCaption.textContent = data.tag.caption;
        }

        behaviorButtons.forEach(btn => {
            btn.addEventListener('click', () => setBehavior(btn.dataset.behavior));
        });

        setBehavior('complexity');
    </script>
</body>

</html>
