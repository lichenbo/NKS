<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sequential Substitution Systems – NKS Chapter 3</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #f5f5f5;
      color: #1f1f1f;
    }
    main { max-width: 820px; margin: 0 auto; padding: 28px 20px 40px; }
    header { margin-bottom: 22px; }
    h1 { margin: 0 0 0.4rem; font-size: 1.85rem; }
    p { margin: 0; line-height: 1.55; }
    section {
      background: #fff;
      border: 1px solid #d8d8d8;
      border-radius: 10px;
      padding: 18px 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    .controls { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    label { display: block; font-weight: 600; margin-bottom: 6px; }
    select, button {
      font: inherit;
      padding: 7px 9px;
      border-radius: 6px;
      border: 1px solid #b6b6b6;
      background: #fff;
      width: 100%;
    }
    button {
      background: #1f63c7;
      border-color: #1f63c7;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    button.secondary {
      background: #f1f1f1;
      border-color: #c2c2c2;
      color: #232323;
    }
    button + button { margin-top: 8px; }
    .output {
      background: #fafafa;
      border: 1px solid #d4d4d4;
      border-radius: 8px;
      padding: 16px;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 0.92rem;
      line-height: 1.4;
      max-height: 380px;
      overflow-y: auto;
    }
    .row { margin-bottom: 8px; }
    .match { background: #ffe066; }
    .rules { margin: 0; padding-left: 18px; }
    .stats { display: flex; flex-wrap: wrap; gap: 16px; font-size: 0.95rem; margin-top: 12px; }
    .stat { min-width: 110px; }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Sequential Substitution Systems</h1>
      <p>
        Chapter 3 also investigates single-substitution dynamics where, at each step, only the leftmost occurrence of the first
        applicable rule is replaced. The presets reproduce the systems from pages 88–89 of the NKS book.
      </p>
    </header>

    <section class="controls">
      <div>
        <label for="preset">Choose system</label>
        <select id="preset">
          <option value="page88">Page 88 – A→AB, BA→A (initial string AABBA)</option>
          <option value="page89">Page 89 – AB→B, BA→A (initial string ABBA)</option>
        </select>
      </div>
      <div>
        <label>Simulation control</label>
        <button id="run-btn">Run</button>
        <button id="step-btn" class="secondary">Step once</button>
        <button id="reset-btn" class="secondary">Reset</button>
      </div>
      <div>
        <label>Active rules</label>
        <ul id="rule-list" class="rules"></ul>
      </div>
    </section>

    <section>
      <div class="output" id="output"></div>
      <div class="stats">
        <div class="stat"><strong>Steps:</strong> <span id="step-count">0</span></div>
        <div class="stat"><strong>Length:</strong> <span id="length">0</span></div>
      </div>
    </section>
  </main>

  <script>
    const PRESETS = {
      page88: {
        initial: 'AABBA',
        rules: [
          { pattern: 'A', replacement: 'AB' },
          { pattern: 'BA', replacement: 'A' }
        ]
      },
      page89: {
        initial: 'ABBA',
        rules: [
          { pattern: 'AB', replacement: 'B' },
          { pattern: 'BA', replacement: 'A' }
        ]
      }
    };

    class SequentialSubstitutionDemo {
      constructor() {
        this.setPreset('page88');
        this.running = false;
        this.timer = null;
      }

      setPreset(name) {
        const preset = PRESETS[name];
        this.initial = preset.initial;
        this.rules = preset.rules;
        this.reset();
        this.renderRules();
      }

      reset() {
        this.stop();
        this.current = this.initial;
        this.history = [{ step: 0, text: this.current, matchStart: -1, matchLength: 0, ruleIndex: -1 }];
        this.render();
      }

      findMatch() {
        for (let index = 0; index < this.rules.length; index++) {
          const rule = this.rules[index];
          const pos = this.current.indexOf(rule.pattern);
          if (pos !== -1) {
            return { ruleIndex: index, position: pos, length: rule.pattern.length };
          }
        }
        return null;
      }

      step() {
        const match = this.findMatch();
        if (!match) {
          this.stop();
          return false;
        }
        const rule = this.rules[match.ruleIndex];
        const before = this.current.slice(0, match.position);
        const after = this.current.slice(match.position + match.length);
        this.current = before + rule.replacement + after;
        const record = {
          step: this.history.length,
          text: this.current,
          matchStart: match.position,
          matchLength: rule.replacement.length,
          ruleIndex: match.ruleIndex
        };
        this.history.push(record);
        this.render();
        return true;
      }

      run() {
        if (this.running) return;
        this.running = true;
        const loop = () => {
          if (!this.running) return;
          const progressed = this.step();
          if (progressed) {
            this.timer = setTimeout(() => requestAnimationFrame(loop), 180);
          }
        };
        loop();
      }

      stop() {
        this.running = false;
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
      }

      renderRules() {
        const list = document.getElementById('rule-list');
        list.innerHTML = '';
        this.rules.forEach((rule, index) => {
          const li = document.createElement('li');
          li.textContent = `${index + 1}. ${rule.pattern} → ${rule.replacement}`;
          list.appendChild(li);
        });
      }

      render() {
        const container = document.getElementById('output');
        container.innerHTML = '';
        this.history.forEach(entry => {
          const div = document.createElement('div');
          div.className = 'row';
          let highlighted;
          if (entry.matchStart >= 0) {
            const prefix = entry.text.slice(0, entry.matchStart);
            const match = entry.text.slice(entry.matchStart, entry.matchStart + entry.matchLength);
            const suffix = entry.text.slice(entry.matchStart + entry.matchLength);
            highlighted = `${prefix}<span class="match">${match}</span>${suffix}`;
          } else {
            highlighted = entry.text;
          }
          div.innerHTML = `${entry.step.toString().padStart(2, '0')}: ${highlighted}`;
          container.appendChild(div);
        });
        const last = this.history[this.history.length - 1];
        document.getElementById('step-count').textContent = (this.history.length - 1).toString();
        document.getElementById('length').textContent = last.text.length.toString();
      }
    }

    const demo = new SequentialSubstitutionDemo();

    document.getElementById('preset').addEventListener('change', (event) => {
      demo.setPreset(event.target.value);
      document.getElementById('run-btn').textContent = 'Run';
    });

    document.getElementById('run-btn').addEventListener('click', () => {
      if (demo.running) {
        demo.stop();
        document.getElementById('run-btn').textContent = 'Run';
      } else {
        demo.run();
        document.getElementById('run-btn').textContent = 'Pause';
      }
    });

    document.getElementById('step-btn').addEventListener('click', () => {
      demo.stop();
      document.getElementById('run-btn').textContent = 'Run';
      demo.step();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      demo.reset();
      document.getElementById('run-btn').textContent = 'Run';
    });
  </script>
</body>
</html>
