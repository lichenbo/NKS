<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mobile Automata – NKS Chapter 3</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #f4f4f4;
      color: #1f1f1f;
    }
    main {
      max-width: 860px;
      margin: 0 auto;
      padding: 28px 20px 40px;
    }
    header { margin-bottom: 20px; }
    h1 { font-size: 1.85rem; margin: 0 0 0.4rem; }
    p { margin: 0; line-height: 1.55; }
    section {
      background: #fff;
      border: 1px solid #d7d7d7;
      border-radius: 10px;
      padding: 18px 20px;
      margin-bottom: 18px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    .controls { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    label { display: block; font-weight: 600; margin-bottom: 6px; }
    select, button {
      font: inherit;
      padding: 7px 9px;
      border-radius: 6px;
      border: 1px solid #b6b6b6;
      background: #fff;
      width: 100%;
    }
    button {
      background: #1f63c7;
      border-color: #1f63c7;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    button.secondary {
      background: #f1f1f1;
      border-color: #c2c2c2;
      color: #232323;
    }
    button + button { margin-top: 8px; }
    canvas {
      width: 100%;
      border: 1px solid #9c9c9c;
      background: #fff;
      display: block;
      image-rendering: pixelated;
    }
    .stats { display: flex; flex-wrap: wrap; gap: 16px; font-size: 0.95rem; margin-top: 12px; }
    .stat { min-width: 120px; }
    #rule-description { margin-top: 12px; line-height: 1.5; font-size: 0.95rem; }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Mobile Automata</h1>
      <p>
        Chapter 3 studies single active-cell mobile automata with two colours and nearest-neighbour motion. The selector below
        enumerates the 16 rules from the original demo. Each rule specifies what happens when the head encounters a white cell
        (0) or a black cell (1): write a new colour and move left or right. The traces plotted here match the behaviour shown on
        the NKS website—revealing how simple sequential update rules already realise Wolfram’s four classes.
      </p>
    </header>

    <section class="controls">
      <div>
        <label for="rule-select">Rule code (0–15)</label>
        <select id="rule-select"></select>
      </div>
      <div>
        <label>Simulation control</label>
        <button id="run-btn">Run</button>
        <button id="step-btn" class="secondary">Step once</button>
        <button id="reset-btn" class="secondary">Reset</button>
      </div>
      <div>
        <label for="head-position">Initial head position</label>
        <select id="head-position">
          <option value="center">Centre cell</option>
          <option value="left">Quarter from left</option>
          <option value="right">Quarter from right</option>
        </select>
      </div>
    </section>

    <section>
      <canvas id="ma-canvas" width="820" height="480"></canvas>
      <div class="stats">
        <div class="stat"><strong>Generation:</strong> <span id="generation">0</span></div>
        <div class="stat"><strong>Head index:</strong> <span id="head-index">0</span></div>
        <div class="stat"><strong>Visited cells:</strong> <span id="visited">0</span></div>
      </div>
      <p id="rule-description"></p>
    </section>
  </main>

  <script>
    const RULE_INFO = [
      { code: 0, text: '0→(write 0, move left); 1→(write 0, move left). The head simply walks left and erases.' },
      { code: 1, text: '0→0L, 1→0R. The head drifts right on black cells but erases white cells on contact.' },
      { code: 2, text: '0→0L, 1→1L. The tape fills with black cells and the head marches steadily left.' },
      { code: 3, text: '0→0L, 1→1R. A simple two-cycle that toggles colours around the head.' },
      { code: 4, text: '0→0R, 1→0L. The head reverses direction whenever it finds a black cell.' },
      { code: 5, text: '0→0R, 1→0R. The head sweeps right leaving blank space behind—pure class 1 behaviour.' },
      { code: 6, text: '0→0R, 1→1L. Produces a short-period oscillator as the head shuttles in place.' },
      { code: 7, text: '0→0R, 1→1R. The head leaves a trail of black cells as it moves right forever.' },
      { code: 8, text: '0→1L, 1→0L. Creates a growing black wedge while the head drifts left.' },
      { code: 9, text: '0→1L, 1→0R. An example of nested growth reminiscent of the printed figure on page 73.' },
      { code: 10, text: '0→1L, 1→1L. The tape fills with ones; motion remains directed left.' },
      { code: 11, text: '0→1L, 1→1R. Reversible local interaction that yields a short periodic orbit.' },
      { code: 12, text: '0→1R, 1→0L. The head alternates direction—one of the few rules that shows longer transients.' },
      { code: 13, text: '0→1R, 1→0R. Builds a staircase of isolated black cells marching right.' },
      { code: 14, text: '0→1R, 1→1L. The head lays down a triangular block of black cells (class 2 behaviour).' },
      { code: 15, text: '0→1R, 1→1R. Every step writes a black cell while the head runs to the right.' }
    ];

    function decodeInstruction(code) {
      const move = (code === 0 || code === 2) ? -1 : 1;
      const write = (code === 0 || code === 1) ? 0 : 1;
      return { move, write };
    }

    class MobileAutomaton {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = 121;
        this.maxGenerations = 220;
        this.cellSize = Math.floor(canvas.width / this.width);
        this.rowHeight = Math.floor(canvas.height / this.maxGenerations);
        this.rule = 9;
        this.instructions = this.buildInstructions(this.rule);
        this.resetState('center');
        this.running = false;
        this.timer = null;
      }

      buildInstructions(ruleNumber) {
        const action0 = decodeInstruction(ruleNumber % 4);
        const action1 = decodeInstruction(Math.floor(ruleNumber / 4) % 4);
        return { 0: action0, 1: action1 };
      }

      resetState(positionPreset) {
        this.stop();
        this.tape = new Array(this.width).fill(0);
        if (positionPreset === 'left') {
          this.head = Math.floor(this.width / 4);
        } else if (positionPreset === 'right') {
          this.head = Math.floor((this.width * 3) / 4);
        } else {
          this.head = Math.floor(this.width / 2);
        }
        this.history = [];
        this.generation = 0;
        this.visited = new Set([this.head]);
        this.pushHistory();
        this.draw();
        this.updateStats();
      }

      setRule(ruleNumber) {
        this.rule = ruleNumber;
        this.instructions = this.buildInstructions(ruleNumber);
        this.resetState(document.getElementById('head-position').value);
      }

      pushHistory() {
        this.history.push({ tape: this.tape.slice(), head: this.head });
        if (this.history.length > this.maxGenerations) {
          this.history.shift();
        }
      }

      step() {
        const current = this.tape[this.head];
        const instruction = this.instructions[current];
        this.tape[this.head] = instruction.write;
        this.head = (this.head + instruction.move + this.width) % this.width;
        this.visited.add(this.head);
        this.generation += 1;
        this.pushHistory();
        this.draw();
        this.updateStats();
      }

      run() {
        if (this.running) return;
        this.running = true;
        const loop = () => {
          if (!this.running) return;
          this.step();
          this.timer = setTimeout(() => requestAnimationFrame(loop), 90);
        };
        loop();
      }

      stop() {
        this.running = false;
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
      }

      draw() {
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        const start = Math.max(0, this.history.length - this.maxGenerations);
        for (let i = start; i < this.history.length; i++) {
          const row = this.history[i].tape;
          const headIndex = this.history[i].head;
          const y = (i - start) * this.rowHeight;
          for (let x = 0; x < this.width; x++) {
            if (row[x] === 1) {
              this.ctx.fillStyle = '#000';
              this.ctx.fillRect(x * this.cellSize, y, this.cellSize, this.rowHeight);
            }
          }
          this.ctx.fillStyle = '#d62828';
          this.ctx.fillRect(headIndex * this.cellSize, y, this.cellSize, this.rowHeight);
        }
      }

      updateStats() {
        document.getElementById('generation').textContent = this.generation.toString();
        document.getElementById('head-index').textContent = this.head.toString();
        document.getElementById('visited').textContent = this.visited.size.toString();
      }
    }

    const canvas = document.getElementById('ma-canvas');
    const automaton = new MobileAutomaton(canvas);

    const ruleSelect = document.getElementById('rule-select');
    for (const info of RULE_INFO) {
      const option = document.createElement('option');
      option.value = info.code;
      option.textContent = `Rule ${info.code}`;
      if (info.code === 9) option.selected = true;
      ruleSelect.appendChild(option);
    }

    const description = document.getElementById('rule-description');
    function updateDescription(code) {
      const item = RULE_INFO.find(entry => entry.code === code);
      description.textContent = item ? item.text : '';
    }

    updateDescription(automaton.rule);

    ruleSelect.addEventListener('change', () => {
      const value = parseInt(ruleSelect.value, 10);
      automaton.setRule(value);
      updateDescription(value);
      document.getElementById('run-btn').textContent = 'Run';
    });

    document.getElementById('head-position').addEventListener('change', (event) => {
      automaton.resetState(event.target.value);
      document.getElementById('run-btn').textContent = 'Run';
    });

    document.getElementById('run-btn').addEventListener('click', () => {
      if (automaton.running) {
        automaton.stop();
        document.getElementById('run-btn').textContent = 'Run';
      } else {
        automaton.run();
        document.getElementById('run-btn').textContent = 'Pause';
      }
    });

    document.getElementById('step-btn').addEventListener('click', () => {
      automaton.stop();
      document.getElementById('run-btn').textContent = 'Run';
      automaton.step();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      automaton.resetState(document.getElementById('head-position').value);
      document.getElementById('run-btn').textContent = 'Run';
    });
  </script>
</body>
</html>
