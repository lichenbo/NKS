<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>分层内容演示 - 第2章</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(26, 26, 26, 0.8);
            padding: 2rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #ffd700;
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        h2 {
            color: #ffd700;
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 0.5rem;
        }

        h3 {
            color: #ffeb3b;
            font-size: 1.2rem;
            margin: 1.5rem 0 1rem 0;
        }

        /* Reading Mode Indicator */
        .reading-mode-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 2rem;
            padding: 12px 16px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .mode-label {
            color: rgba(255, 215, 0, 0.8);
            font-weight: 500;
        }

        .mode-toggle {
            padding: 8px 16px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 16px;
            background: transparent;
            color: rgba(255, 215, 0, 0.7);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .mode-toggle:hover {
            background: rgba(255, 215, 0, 0.1);
            color: rgba(255, 215, 0, 0.9);
            border-color: rgba(255, 215, 0, 0.6);
        }

        .mode-toggle.active {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border-color: rgba(255, 215, 0, 0.8);
            font-weight: 500;
        }

        /* Content Layers */
        .content-layer {
            margin-bottom: 1rem;
            transition: opacity 0.3s ease;
        }

        .content-layer.detailed {
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }

        .content-layer.active-layer {
            position: relative;
            border-left: 3px solid #ffd700;
            padding-left: 12px;
        }

        /* Expand Toggle Button */
        .expand-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 1rem 0;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            color: rgba(255, 215, 0, 0.8);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .expand-toggle:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            color: #ffd700;
            transform: translateY(-1px);
        }

        .toggle-icon {
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }

        .expand-toggle[data-expanded="true"] .toggle-icon {
            transform: rotate(180deg);
        }

        /* Chapter Summary */
        .chapter-summary {
            margin-top: 2rem;
            padding: 16px 20px;
            border-radius: 8px;
            position: relative;
        }

        .chapter-summary.simplified {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .chapter-summary.detailed {
            background: rgba(63, 81, 181, 0.1);
            border: 1px solid rgba(63, 81, 181, 0.3);
        }

        /* Lists and emphasis */
        ul, ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        li {
            margin: 0.5rem 0;
        }

        blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            font-style: italic;
        }

        strong {
            color: #ffd700;
        }

        .annotation-link {
            color: #64b5f6;
            text-decoration: underline;
            cursor: pointer;
        }

        .annotation-link:hover {
            color: #90caf9;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .reading-mode-indicator {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .mode-toggle {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>第2章：关键实验</h1>

        <div class="reading-mode-indicator">
            <span class="mode-label">阅读模式：</span>
            <button class="mode-toggle active" data-mode="simplified">简化版</button>
            <button class="mode-toggle" data-mode="detailed">详细版</button>
        </div>

        <section>
            <h2>简单程序的行为如何？</h2>

            <div class="content-layer simplified active-layer">
                <p><strong>核心问题</strong>：如果我们运行一些非常简单的计算机程序，会发生什么？</p>
                
                <p>在日常生活中，我们使用的计算机程序都是为了完成特定任务而设计的。但是，如果我们随意选择一些简单的程序，仅仅是为了观察它们的行为，会得到什么结果呢？</p>
                
                <p>为了回答这个问题，我研究了一类叫做<strong><span class="annotation-link">细胞自动机</span></strong>的简单程序。</p>
            </div>

            <div class="content-layer detailed" style="display: none;">
                <p>科学上的新方向，通常源于某些核心的观察或实验。对于本书所描述的这门新科学而言，这些观察和实验关乎<strong>简单程序的行为</strong>。</p>
                
                <p>在日常使用计算机的经验中，我们遇到的程序通常是为了执行非常明确的任务而设计的。但近二十年前我产生了一个关键想法——这个想法最终促成了本书中这门全新的科学——那就是去探究，如果我们不带任何特定任务的意图，只是观察随意选择的简单程序，会发生什么。这样的程序通常表现出怎样的行为？</p>
                
                <p>过去主导理论科学的数学方法，对于回答这类问题帮助不大。但有了计算机，我们就可以直接通过实验来研究它。我们所要做的，仅仅是建立一系列可能的简单程序，然后运行它们，观察其行为。</p>
                
                <p>任何程序在某种层面上都可以被看作是一套规则的集合，这些规则指定了程序在每一步应该做什么。设置这些规则的方式多种多样——实际上，在本书的进程中，我们将会研究其中的几种。但现在，我将考虑一类特殊的例子，称为<span class="annotation-link">细胞自动机</span>，这是我在1980年代初研究的第一类简单程序。</p>
            </div>

            <button class="expand-toggle" data-target="simplified" data-expanded="false">
                <span class="toggle-text">展开详细内容</span>
                <span class="toggle-icon">▼</span>
            </button>
        </section>

        <section>
            <h2>细胞自动机的可视化</h2>

            <div class="content-layer simplified active-layer">
                <p><span class="annotation-link">细胞自动机</span>是一种非常简单的计算模型：</p>
                
                <ul>
                    <li>由一行黑白方格组成</li>
                    <li>每个方格的颜色根据简单规则决定</li>
                    <li>规则只看这个方格和它左右两个邻居的颜色</li>
                    <li>每一步都应用相同的规则</li>
                </ul>
            </div>

            <div class="content-layer detailed" style="display: none;">
                <p>细胞自动机的一个重要特性是，它们的行为可以很容易地以视觉方式呈现。下面的图片展示了一个细胞自动机在十个步骤中的演化过程。</p>
                
                <img src="https://wolframscience.com/nks/images/rule-254-steps.gif" alt="Rule 254" style="max-width: 100%; height: auto;">
                
                <p>这个细胞自动机由一行单元格组成，每个单元格的颜色非黑即白。在每一步，都有一个明确的规则根据一个给定单元格及其左右紧邻邻居在前一步的颜色，来决定该单元格的当前颜色。</p>
                
                <p>对于这里展示的特定细胞自动机，规则规定——如下面的图片所示——在任何一个单元格或其任一邻居在前一步是黑色的情况下，该单元格在当前步骤中应为黑色。</p>

                <img src="https://wolframscience.com/nks/images/rule-254-diagram.png" alt="Rule 254 Diagram" style="max-width: 100%; height: auto;">

                <p>如页面顶部的图片所示，从中心的一个黑色单元格开始，这个规则导致了一个简单增长的、均匀填充黑色的模式。但只需对规则稍作修改，就能立刻得到一个不同的模式。</p>

                <p>作为第一个例子，下方的图片展示了当规则变为"如果一个单元格的两个邻居在前一步都是白色，则该单元格变为白色——即使它自己之前是黑色的"时会发生什么。这个规则不再产生一个均匀填充黑色的图案，而是生成了一个像棋盘一样黑白交替的重复图案。</p>

                <img src="https://wolframscience.com/nks/images/rule-250-steps.gif" alt="Rule 250" style="max-width: 100%; height: auto;">

                <p>然而，这个图案同样相当简单。我们可能会假设，至少对于我们正在考虑的这类细胞自动机，我们选择的任何规则总是会产生一个相当简单的图案。但现在，我们将迎来第一个惊喜。</p>

                <p>下面的图片展示了由一个与之前类型相同，但规则略有不同的细胞自动机产生的图案。</p>

                <img src="https://wolframscience.com/nks/images/rule-90-steps.gif" alt="Rule 90" style="max-width: 100%; height: auto;">

                <p>这一次，规则规定，当一个单元格的左邻居或右邻居——但不是两者同时——在前一步是黑色时，该单元格应为黑色。同样，这个规则无疑是简单的。但现在图片显示，它产生的图案却不那么简单。</p>

                <p>如果我们让这个细胞自动机运行更多步骤，如下图所示，一个相当复杂的图案就会出现。但我们现在可以看到，这个图案具有非常明确的规律性。尽管它很复杂，但我们可以看到它实际上由许多嵌套的三角形部分组成，这些部分都具有完全相同的形式。并且，正如图片所示，这些部分中的每一个本质上都是整个图案的一个较小副本，内部以非常规则的方式嵌套着更小的副本。这种具有嵌套结构的图案通常被称为"<span class="annotation-link">分形</span>"或"自相似"。</p>

                <img src="https://wolframscience.com/nks/images/rule-90-large.png" alt="Rule 90 Large" style="max-width: 100%; height: auto;">

                <p>因此，到目前为止我们看到的三个细胞自动机，最终都产生了高度规则的图案：第一个是简单的统一图案，第二个是重复图案，第三个是复杂但仍是嵌套的图案。我们可能会假设，至少对于我们一直在使用的这些规则一样简单的细胞自动机，这三种行为形式就是我们所能得到的全部。</p>

                <p>但值得注意的是，事实证明这是错误的。</p>

                <p>下面的图片展示了这样一个例子。所使用的规则——我称之为<strong><span class="annotation-link">规则30</span></strong>——与之前的规则完全属于同一类型，可以描述如下：首先，查看每个单元格及其右侧邻居。如果它们在前一步都是白色，则该单元格的新颜色将与其左侧邻居的前一颜色相同。否则，新颜色将是其左侧邻居前一颜色的反色。</p>

                <img src="https://wolframscience.com/nks/images/rule-30-steps.gif" alt="Rule 30" style="max-width: 100%; height: auto;">

                <p>这张图片展示了从一个黑色单元格开始，反复应用此规则后发生的情况。我们看到的是一些相当惊人的东西——可能是我有史以来做出的最令人惊讶的科学发现。我们可能期望得到一个简单的规则模式，但这个细胞自动机产生的模式看起来却极其不规则和复杂。</p>
            </div>

            <button class="expand-toggle" data-target="simplified" data-expanded="false">
                <span class="toggle-text">展开详细内容</span>
                <span class="toggle-icon">▼</span>
            </button>
        </section>

        <section>
            <h2>四种基本行为模式</h2>

            <div class="content-layer simplified active-layer">
                <p>通过实验，我发现简单的细胞自动机会产生四种不同的行为：</p>
                
                <h3>1. 简单均匀模式</h3>
                <p>有些规则产生完全统一的图案，比如全部变成黑色。</p>
                
                <h3>2. 重复模式</h3>
                <p>有些规则产生有规律重复的图案，比如棋盘式的黑白交替。</p>
                
                <h3>3. 复杂嵌套模式</h3>
                <p>有些规则产生<span class="annotation-link">分形</span>图案——复杂但有嵌套结构的三角形模式。</p>
                
                <h3>4. 随机复杂模式 ⭐</h3>
                <p><strong><span class="annotation-link">规则30</span></strong>产生看起来完全随机的复杂图案。这是最重要的发现！</p>
            </div>

            <div class="content-layer detailed" style="display: none;">
                <h3>第一种：简单均匀模式</h3>
                <p>如前面的图片所示，从中心的一个黑色单元格开始，这个规则导致了一个简单增长的、均匀填充黑色的模式。但只需对规则稍作修改，就能立刻得到一个不同的模式。</p>
                
                <h3>第二种：重复模式</h3>
                <p>作为第一个例子，当规则变为"如果一个单元格的两个邻居在前一步都是白色，则该单元格变为白色——即使它自己之前是黑色的"时会发生什么。这个规则不再产生一个均匀填充黑色的图案，而是生成了一个像棋盘一样黑白交替的重复图案。</p>
                
                <h3>第三种：复杂嵌套模式（分形）</h3>
                <p>规则规定，当一个单元格的左邻居或右邻居——但不是两者同时——在前一步是黑色时，该单元格应为黑色。同样，这个规则无疑是简单的。但现在图片显示，它产生的图案却不那么简单。</p>
                
                <p>如果我们让这个细胞自动机运行更多步骤，一个相当复杂的图案就会出现。但我们现在可以看到，这个图案具有非常明确的规律性。尽管它很复杂，但我们可以看到它实际上由许多嵌套的三角形部分组成，这些部分都具有完全相同的形式。</p>
                
                <h3>第四种：随机复杂模式——规则30</h3>
                <p>但值得注意的是，事实证明前面三种行为并不是全部。</p>
                
                <p>所使用的规则——我称之为<strong><span class="annotation-link">规则30</span></strong>——与之前的规则完全属于同一类型，可以描述如下：首先，查看每个单元格及其右侧邻居。如果它们在前一步都是白色，则该单元格的新颜色将与其左侧邻居的前一颜色相同。否则，新颜色将是其左侧邻居前一颜色的反色。</p>
                
                <p>这张图片展示了从一个黑色单元格开始，反复应用此规则后发生的情况。我们看到的是一些相当惊人的东西——可能是我有史以来做出的最令人惊讶的科学发现。我们可能期望得到一个简单的规则模式，但这个细胞自动机产生的模式看起来却极其不规则和复杂。</p>
            </div>

            <button class="expand-toggle" data-target="simplified" data-expanded="false">
                <span class="toggle-text">展开详细内容</span>
                <span class="toggle-icon">▼</span>
            </button>
        </section>

        <section>
            <h2>重要发现与意义</h2>

            <div class="content-layer simplified active-layer">
                <p>这些实验揭示了一个根本性的发现：</p>
                
                <blockquote>
                    <strong>即使系统的规则极其简单，即使从最简单的初始条件开始，系统的行为仍然可以变得高度复杂。</strong>
                </blockquote>
                
                <p><strong>重要意义</strong>：</p>
                <ul>
                    <li>挑战了我们的基本直觉</li>
                    <li>可能解释自然界中复杂性的起源</li>
                    <li>需要建立全新的科学思维方式</li>
                </ul>
            </div>

            <div class="content-layer detailed" style="display: none;">
                <h3>复杂性的起源</h3>
                <p>但这种复杂性从何而来？我们设置系统时，肯定没有以任何直接的方式将它植入。我们只是用了一个简单的细胞自动机规则，并从一个包含单个黑色单元格的简单初始条件开始。</p>
                
                <p>然而图片显示，尽管如此，其行为中却出现了巨大的复杂性。实际上，我们在这里看到的是一个极其普遍和基本现象的第一个例子，这个现象正是我在这本书中发展的新科学的核心。我们将一次又一次地看到同样的事情：即使一个系统的底层规则很简单，即使系统从简单的初始条件开始，它所展示的行为仍然可以变得高度复杂。我将论证，正是这个基本现象最终导致了我们在自然界中看到的大部分复杂性。</p>
                
                <h3>新直觉的需求</h3>
                <p>前一节的图片清楚地表明，只需要非常简单的规则就能产生高度复杂的行为。然而，起初这可能看起来几乎难以置信。因为它违背了我们一些关于事物通常如何运作的最基本的直觉。</p>
                
                <p>因为我们的日常经验使我们期望，看起来复杂的东西必须是以复杂的方式构建的。但实验结果表明，至少有时候，这样的假设可能是完全错误的。</p>
                
                <p>那么，是什么让我们的正常直觉失效呢？最重要的似乎是，它主要来源于建造东西和进行工程的经验——在这些领域，我们恰好会避免遇到像前面那样的系统。因为通常我们从我们想要得到的任何行为开始，然后尝试设计一个能够产生这种行为的系统。</p>
                
                <p>但与工程不同，自然界不在这样的约束下运作。因此，没有什么能阻止像前面那样的系统出现。事实上，本书的重要结论之一是，这样的系统在自然界中实际上非常普遍。</p>
            </div>

            <button class="expand-toggle" data-target="simplified" data-expanded="false">
                <span class="toggle-text">展开详细内容</span>
                <span class="toggle-icon">▼</span>
            </button>
        </section>

        <div class="chapter-summary simplified">
            <strong>本章核心观点</strong>：简单的规则可以产生极其复杂的行为，这是一个普遍而基本的现象，是理解自然界复杂性的关键。
        </div>

        <div class="chapter-summary detailed" style="display: none;">
            <strong>本章总结</strong>：通过对细胞自动机的系统研究，我们发现了一个革命性的现象——即使是极其简单的规则，从极其简单的初始条件开始，也能产生高度复杂的行为。这个发现不仅挑战了我们关于复杂性起源的基本直觉，也为理解自然界中的复杂现象提供了全新的视角。这种基于简单程序的复杂性现象，可能是自然界中大部分复杂性的真正来源。
        </div>
    </div>

    <script>
        class LayeredContentDemo {
            constructor() {
                this.currentMode = 'simplified';
                this.init();
            }

            init() {
                this.createModeToggleListeners();
                this.createExpandToggleListeners();
                this.updateContentVisibility();
            }

            createModeToggleListeners() {
                document.addEventListener('click', (e) => {
                    const modeToggle = e.target.closest('.mode-toggle');
                    if (!modeToggle) return;

                    const newMode = modeToggle.dataset.mode;
                    if (newMode !== this.currentMode) {
                        this.switchMode(newMode);
                    }
                });
            }

            createExpandToggleListeners() {
                document.addEventListener('click', (e) => {
                    const expandToggle = e.target.closest('.expand-toggle');
                    if (!expandToggle) return;

                    this.toggleSection(expandToggle);
                });
            }

            switchMode(newMode) {
                this.currentMode = newMode;
                this.updateModeButtons();
                this.updateContentVisibility();
                
                // Smooth scroll to top when switching modes
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }

            updateModeButtons() {
                const modeButtons = document.querySelectorAll('.mode-toggle');
                modeButtons.forEach(btn => {
                    const isActive = btn.dataset.mode === this.currentMode;
                    btn.classList.toggle('active', isActive);
                });
            }

            updateContentVisibility() {
                const simplifiedLayers = document.querySelectorAll('.content-layer.simplified');
                const detailedLayers = document.querySelectorAll('.content-layer.detailed');
                const expandToggles = document.querySelectorAll('.expand-toggle');
                const summaries = document.querySelectorAll('.chapter-summary');

                if (this.currentMode === 'simplified') {
                    // Show simplified content
                    simplifiedLayers.forEach(layer => {
                        layer.style.display = 'block';
                        layer.classList.add('active-layer');
                    });

                    // Hide detailed content
                    detailedLayers.forEach(layer => {
                        layer.style.display = 'none';
                        layer.classList.remove('active-layer');
                    });

                    // Show expand toggles
                    expandToggles.forEach(toggle => {
                        toggle.style.display = 'flex';
                        toggle.dataset.expanded = 'false';
                        this.updateToggleText(toggle, false);
                    });

                    // Show simplified summary
                    summaries.forEach(summary => {
                        const isSimplified = summary.classList.contains('simplified');
                        summary.style.display = isSimplified ? 'block' : 'none';
                    });

                } else if (this.currentMode === 'detailed') {
                    // Show detailed content
                    detailedLayers.forEach(layer => {
                        layer.style.display = 'block';
                        layer.classList.add('active-layer');
                    });

                    // Hide simplified content and toggles
                    simplifiedLayers.forEach(layer => {
                        layer.style.display = 'none';
                        layer.classList.remove('active-layer');
                    });

                    expandToggles.forEach(toggle => {
                        toggle.style.display = 'none';
                    });

                    // Show detailed summary
                    summaries.forEach(summary => {
                        const isDetailed = summary.classList.contains('detailed');
                        summary.style.display = isDetailed ? 'block' : 'none';
                    });
                }
            }

            toggleSection(toggleButton) {
                const isExpanded = toggleButton.dataset.expanded === 'true';
                const section = toggleButton.closest('section');
                const detailedLayer = section.querySelector('.content-layer.detailed');

                if (!detailedLayer) return;

                if (!isExpanded) {
                    // Expand to show detailed content
                    detailedLayer.style.display = 'block';
                    detailedLayer.style.maxHeight = detailedLayer.scrollHeight + 'px';
                    toggleButton.dataset.expanded = 'true';
                    
                    // Smooth scroll to bring detailed content into view
                    setTimeout(() => {
                        detailedLayer.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest' 
                        });
                    }, 100);
                } else {
                    // Collapse to hide detailed content
                    detailedLayer.style.maxHeight = '0px';
                    setTimeout(() => {
                        detailedLayer.style.display = 'none';
                    }, 300);
                    toggleButton.dataset.expanded = 'false';
                }

                this.updateToggleText(toggleButton, !isExpanded);
            }

            updateToggleText(toggle, isExpanded) {
                const textElement = toggle.querySelector('.toggle-text');
                const iconElement = toggle.querySelector('.toggle-icon');
                
                if (textElement) {
                    textElement.textContent = isExpanded ? '收起详细内容' : '展开详细内容';
                }
                
                if (iconElement) {
                    iconElement.textContent = isExpanded ? '▲' : '▼';
                }
            }
        }

        // Initialize the demo when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new LayeredContentDemo();
        });
    </script>
</body>
</html>